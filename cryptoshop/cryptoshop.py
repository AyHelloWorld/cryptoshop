#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Cryptoshop Strong file encryption.
# Encrypt and decrypt file in GCM mode with AES, Serpent or Twofish as secure as possible.
# Copyright(C) 2016 CORRAIRE Fabrice. antidote1911@gmail.com

# ############################################################################
# This file is part of Cryptoshop-GUI (full Qt5 gui for Cryptoshop).
#
#    Cryptoshop is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    Cryptoshop is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Cryptoshop.  If not, see <http://www.gnu.org/licenses/>.
# ############################################################################

"""
    Cryptoshop implementation.
    Encrypt and decrypt file in GCM mode with AES, Serpent or Twofish as secure as possible.

    Usage:
    from cryptoshop import encryptfile
    from cryptoshop import decryptfile

    result1 = encryptfile(filename="test", passphrase="mypassword", algo="srp")
    print(result1)

    result2 = decryptfile(filename="test.cryptoshop", passphrase="mypassword")
    print(result2)

"""

import os
import sys

from tqdm import *

from .derivation import calc_derivation
from .settings import __version__
from .nonce import generate_nonce_timestamp
from .internalkey import encry_decry_internalkey

try:
    import botan
except:
    print("Please install the last version of Botan crypto library.")
    print("http://botan.randombit.net/#download")
    print("For Linux users, try to find it in your package manager.")
    sys.exit(0)

salt_size = 512  # in bits.(64 bytes)
chunk_size = 5000000  # in bytes. (0.5 Mo)
version = bytes(__version__.encode('utf-8'))

# ------------------------------------------------------------------------------
# Constant variables
# ------------------------------------------------------------------------------
internal_key_length = 32  # in bytes (256 bits).
nonce_length = 21  # in bytes (168 bits).
gcmtag = 16  # in bytes (128 bits) the tag generated by GCM.
encrypted_key_length = 143  # in bytes (1144 bits)
fileheader_length = 20  # in bits (2.5 bytes)


def _encry_decry_chunk(chunk, key, algo, bool_encry, assoc_data):
    """
    When bool_encry is True, encrypt a chunk of the file with the key and a randomly generated nonce. When it is False,
    the function extract the nonce from the cipherchunk (first 16 bytes), and decrypt the rest of the chunk.
    :param chunk: a chunk in bytes to encrypt or decrypt.
    :param key: a 32 bytes key in bytes.
    :param bool_encry: if bool_encry is True, chunk is encrypted. Else, it will be decrypted.
    :return: if bool_encry is True, corresponding nonce + cipherchunk else, a decrypted chunk.
    """
    engine = botan.cipher(algo=algo, encrypt=bool_encry)
    engine.set_key(key=key)
    engine.set_assoc_data(assoc_data)
    if bool_encry is True:
        nonce = generate_nonce_timestamp()
        engine.start(nonce=nonce)
        return nonce + engine.finish(chunk)
    else:
        nonce = chunk[:nonce_length]
        encryptedchunk = chunk[nonce_length:nonce_length + gcmtag + chunk_size]
        engine.start(nonce=nonce)
        decryptedchunk = engine.finish(encryptedchunk)
        if decryptedchunk == b"":
            raise Exception("Integrity failure: Invalid passphrase or corrupted data")
        else:
            return decryptedchunk


def encryptstring():
    print("encryptstring")


def decryptstring():
    print("decryptstring")


def encryptfile(filename, passphrase, algo='srp'):
    """
    Encrypt a file and write it with .cryptoshop extension.
    :param filename: a string with the path to the file to encrypt.
    :param passphrase: a string with the user passphrase.
    :param algo: a string with the algorithm. Can be srp, aes, twf. Default is srp.
    :return: a string with "successfully encrypted" or error.
    """
    try:
        if algo == "srp":
            header = b"Cryptoshop srp " + version
            crypto_algo = "Serpent/GCM"
        if algo == "aes":
            header = b"Cryptoshop aes " + version
            crypto_algo = "AES-256/GCM"
        if algo == "twf":
            header = b"Cryptoshop twf " + version
            crypto_algo = "Twofish/GCM"
        if algo != "srp" and algo != "aes" and algo != "twf":
            return "No valid algo. Use 'srp' 'aes' or 'twf'"
        outname = filename + ".cryptoshop"

        internal_key = botan.rng().get(internal_key_length)

        # Passphrase derivation...
        salt = botan.rng().get(salt_size)
        masterkey = calc_derivation(passphrase=passphrase, salt=salt)

        # Encrypt internal key...
        encrypted_key = encry_decry_internalkey(internalkey=internal_key, masterkey=masterkey,
                                                bool_encry=True,
                                                assoc_data=header + salt)
        with open(filename, 'rb') as filestream:
            with open(str(outname), 'wb') as filestreamout:
                filestreamout.write(header)
                filestreamout.write(salt)
                filestreamout.write(encrypted_key)
                file_size = os.stat(filename).st_size
                finished = False
                # the maximum of the progress bar is the total chunk to process. It's files_size // chunk_size
                bar = tqdm(range(file_size // chunk_size))
                while not finished:
                    chunk = filestream.read(chunk_size)
                    if len(chunk) == 0 or len(chunk) % chunk_size != 0:
                        finished = True
                    # An encrypted-chunk output is nonce, gcmtag, and cipher-chunk concatenation.
                    encryptedchunk = _encry_decry_chunk(chunk=chunk, key=internal_key, bool_encry=True,
                                                        algo=crypto_algo, assoc_data=header + salt + encrypted_key)
                    filestreamout.write(encryptedchunk)
                    bar.update(1)

            return "successfully encrypted"

    except IOError:
        exit("Error: file \"" + filename + "\" was not found.")


def decryptfile(filename, passphrase):
    """
    Decrypt a file and write corresponding decrypted file. We remove the .cryptoshop extension.
    :param filename: a string with the path to the file to decrypt.
    :param passphrase: a string with the user passphrase.
    :return: a string with "successfully decrypted" or error.
    """
    try:
        outname = os.path.splitext(filename)[0].split("_")[-1]  # create a string file name without extension.
        with open(filename, 'rb') as filestream:
            fileheader = filestream.read(fileheader_length)

            if fileheader == b"Cryptoshop srp " + version:
                decrypt_algo = "Serpent/GCM"
            if fileheader == b"Cryptoshop aes " + version:
                decrypt_algo = "AES-256/GCM"
            if fileheader == b"Cryptoshop twf " + version:
                decrypt_algo = "Twofish/GCM"
            if fileheader != b"Cryptoshop srp " + version and fileheader != b"Cryptoshop aes " + version and fileheader != b"Cryptoshop twf " + version:
                return "Error: Bad header"

            salt = filestream.read(salt_size)
            encrypted_key = filestream.read(encrypted_key_length)

            # Derive the passphrase...
            masterkey = calc_derivation(passphrase=passphrase, salt=salt)

            # Decrypt internal key...
            try:
                internal_key = encry_decry_internalkey(internalkey=encrypted_key, masterkey=masterkey,
                                                       bool_encry=False, assoc_data=fileheader + salt)
            except Exception as e:
                return e

            with open(str(outname), 'wb') as filestreamout:
                files_size = os.stat(filename).st_size

                # the maximum of the progress bar is the total chunk to process. It's files_size // chunk_size
                bar = tqdm(range(files_size // chunk_size))
                while True:
                    # Don't forget... an encrypted chunk is nonce, gcmtag, and cipher-chunk concatenation.
                    encryptedchunk = filestream.read(nonce_length + gcmtag + chunk_size)
                    if len(encryptedchunk) == 0:
                        break

                    # Chunk decryption.
                    try:
                        original = _encry_decry_chunk(chunk=encryptedchunk, key=internal_key, algo=decrypt_algo,
                                                      bool_encry=False, assoc_data=fileheader + salt + encrypted_key)
                    except Exception as e:
                        return e
                    else:
                        filestreamout.write(original)
                        bar.update(1)

        return "successfully decrypted"

    except IOError:
        exit("Error: file \"" + filename + "\" was not found.")
